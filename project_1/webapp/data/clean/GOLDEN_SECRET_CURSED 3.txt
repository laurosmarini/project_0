General code review
Act as a senior engineer. Review the following code for correctness, readability, maintainability, and testability. Identify issues by severity (blocker/major/minor) and propose concrete fixes with short justifications.

Produce a structured review with sections: Summary, Strengths, Risks, Bugs, Design Concerns, Naming/Style, Tests Missing, Suggested Refactors. End with a prioritized fix list and estimated effort.

Evaluate adherence to team standards (lint rules, naming, layering). Point out deviations and suggest changes with code diffs. Include at least three targeted unit tests to add.

For each function, list preconditions, postconditions, and invariants inferred from the code. Flag any violations or missing checks and show how to enforce them.

Identify dead code, feature flags past expiry, or unreachable branches. Propose a safe removal plan and tests ensuring no behavior change.

Debugging with symptoms
Given a bug report (steps to reproduce, expected vs actual), isolate likely fault lines in the code. Propose a minimal change that fixes the bug and attach micro tests demonstrating the failure and the fix.

Explain a failing test by tracing data flow through the code. Include a rough call graph and the first line where state diverges from expectation.

For an intermittent bug, propose a logging/trace plan: what to log, where, and at which levels to minimize noise while capturing root cause. Provide redaction rules.

Reproduce a memory leak hypothesis: identify allocations without release paths, propose ownership changes or RAII/with-context usage, and write a small repro harness.

Diagnose a performance regression: instrument with lightweight timers, produce a flame-like breakdown (text), identify hot paths, and propose two alternative fixes with complexity analysis.

Language-specific prompts
Python: Review a module for mutable default args, exception handling granularity, context manager usage, and itertools misuse. Provide idiomatic rewrites.

Python: Identify concurrency hazards in asyncio code: missing awaits, shared state without locks, blocking calls on event loop. Propose safe patterns.

JavaScript/TypeScript: Review for promise handling, microtask vs macrotask pitfalls, and missing return in async chains. Add types and tighten generics.

JavaScript/TypeScript React: Locate unnecessary re-renders. Propose memoization (memo, useMemo, useCallback) with dependency reasoning and show before/after renders.

Java: Inspect for null-safety, Optional misuse, Stream performance pitfalls, and synchronization errors. Suggest modern APIs and immutability where helpful.

Go: Audit for error handling quality, context propagation, goroutine leaks, and unsafe shared maps. Provide race-test guidance.

C/C++: Review for lifetime issues, dangling pointers, copy vs move semantics, and exception-safety. Propose RAII/unique_ptr/shared_ptr conversions.

Rust: Identify ownership/borrow issues, unwrap panics, and error propagation patterns. Suggest Result usage and ergonomic lifetimes.

Security-focused review
Review inputs/outputs for injection risks (SQL, XSS, command, path traversal). For each sink, show a sanitized version with appropriate encoding/parameterization.

Inspect authN/authZ boundaries. Draw a quick access control matrix. Point out missing checks and propose middleware/attribute guards.

Evaluate crypto usage: key generation, IV randomness, mode selection, and error handling. Replace weak primitives and explain trade-offs.

Review secret handling: env var loading, config files, logs, crash reports, and third-party SDKs. Propose a vault integration and redaction strategy.

Analyze multi-tenant isolation: ensure tenant_id is enforced at read/write layers. Propose tests that prove isolation under pagination and caching.

Testing and reproducibility
List critical missing tests by category: boundary, property-based, concurrency, fuzz, snapshot, and regression. Provide concrete test names and inputs.

Convert an integration test relying on real services into a deterministic test using fakes/mocks. Show fixture design and failure case coverage.

Add property-based tests for a pure function. Define properties, input generators, and shrinking strategy.

Propose a flaky-test triage plan: classify by root cause (time, async race, network, precision). Show stabilization tactics for each class.

Create a minimal reproducible example (MRE): shrink the provided code until the bug persists in 30 lines, then explain the trigger.

Performance and scalability
Conduct a complexity review. For each hot function, state time/space complexity and expected inputs. Suggest faster data structures or algorithms and show a micro-benchmark plan.

Identify unnecessary allocations, copies, or JSON/string conversions. Suggest pooling, streaming, or zero-copy patterns with before/after memory profiles.

Review database interactions: N+1 queries, missing indexes, unbounded scans, pagination strategy. Propose specific SQL/index changes and verify with EXPLAIN.

Evaluate caching: key design, TTL/invalidations, cache stampede protection, and SWR. Provide test cases for correctness under churn.

Assess concurrency model and backpressure: queues, thread pools, timeouts, retries, and circuit breakers. Provide safe defaults and chaos test ideas.

Maintainability and design
Refactor a large function into smaller pure functions. Provide a diff and justify boundaries using SRP and cyclomatic complexity reduction.

Introduce a ports-and-adapters (hexagonal) structure. Identify domain, application, and infrastructure parts in the code and propose interfaces.

Replace shared mutable state with dependency injection and pure functions where possible. Provide a small example conversion.

Define a domain type system: replace primitives with value objects or branded types to prevent unit/ID mix-ups; show compiler-aided safety improvements.

Add tracing and structured logging fields that would aid future debugging; define a minimal schema: trace_id, tenant_id, user_id, resource_id, op, duration_ms, outcome.

Review checklists (drop-in)
Apply this checklist and output a table: correctness, safety, performance, readability, testability, observability, i18n, accessibility, docs. Rate 15, justify each, include examples.

Run a bug hunt pass: list top 10 suspicious lines with rationale (e.g., off-by-one, null deref, unbounded recursion). Provide quick probes/tests to confirm each suspicion.

Security mini-checklist: input validation, output encoding, authZ checks, secret management, cryptography, dependency risk. Add 12 tests per item.

API review: consistency of status codes, error schema, pagination, idempotency, timeouts/retries, and rate-limit headers. Provide examples and a contract-test outline.

Frontend review: accessibility labels, focus management, keyboard nav, color contrast, and reduced-motion. Suggest concrete fixes and axe-core checks.

Paste code here versions
Review the following code for correctness and edge cases. Paste a minimal diff showing only the necessary fix and one added test. Then explain the root cause in 120 words.

Debug the following intermittent failure. Propose three logging statements and one invariant check that would have caught it earlier. Then provide the smallest possible code change to fix it.

Optimize the following function. Provide a faster version, complexity analysis, and a micro-benchmark scaffold. Ensure identical outputs across 20 randomized test cases.

Harden the following handler against injection and race conditions. Show a safe version, list specific mitigated CWEs, and add two security tests.

Convert this integration test into a hermetic unit test with a fake dependency. Show the new test and the seam you introduced in the code.

Red-team style prompts
Find and explain the most dangerous bug you can locate in this snippet within 10 minutes. Provide a proof-of-concept input that triggers it and a safe patch.

Given this PR diff, predict two realistic regressions it might introduce in production. Provide guard tests to prevent them.

Assume a junior wrote this module under time pressure. List five gotchas likely to bite later in prod, and show how to defuse each now.

Perform a failure modes and effects analysis (FMEA) on this component. Output a table with failure mode, effect, detectability, severity, and mitigations.

Write a regression test first that reproduces this bug description; then modify the code minimally so the test passes. Provide the commit message.

If desired, these can be converted into templates that enforce strict output formats (e.g., JSON review report, unified diff, or a test plan markdown) to make evaluation objective and automatable.